
process client_cnam [
     request_cnam: out request_cnam_type, reply_cnam: in reply_cnam_type
     ] is

states init_, send, wait_after_rqst, wait_reply, managed_reply, finish

var
    cnam_rq: request_cnam_type,
    cnam_rp: reply_cnam_type,
    cnam_rqid: CNAM_RQSTID_FCR,

    cnam_exp_rq: exp_request_cnam,
    cnam_exp_rp: exp_reply_cnam,

    cnamq: queue 10 of exp_request_cnam:= {|
      {rqid=CNAM_RQ(CNAM_ColorTrack_RQSTID_FCR), grid=0, fr=true, ir=true, wait_cycle=100},
      {rqid=CNAM_RQ(CNAM_ColorTrack_RQSTID_FCR), grid=0, fr=true, ir=true, wait_cycle=0} //,
//      {rqid=CNAM_RQ(CNAM_kill_RQSTID_FCR), grid=0, fr=true, ir=true, wait_cycle=0}
    |},

    wait_cycle: nat := 0,

    exp_rep: 0..10 := 10,
    grid: nat := 0

from init_
   wait [0,0];
   exp_rep := length(cnamq);
   to send

from send
   select
      if (not (empty(cnamq))) then
         cnam_exp_rq := first(cnamq);
         cnamq := dequeue(cnamq);
	 wait_cycle :=  cnam_exp_rq.wait_cycle;
         case cnam_exp_rq.rqid of
            CNAM_RQ(cnam_rqid) ->
                cnam_rq := { rqid = cnam_rqid, grid = grid};
                request_cnam!cnam_rq
         |
            CNAM_RQ_NONE -> null
         end;
         grid := grid + 1;
         to wait_after_rqst
      else
         to wait_reply
      end
   []
      reply_cnam?cnam_rp;
      to managed_reply
   end

from wait_after_rqst
   if (wait_cycle > 0) then
      wait_cycle := wait_cycle - 1;
      select
         wait [0,10];
         to wait_after_rqst
      []
         reply_cnam?cnam_rp;
         to managed_reply
      end
   else  
      to send
   end

from wait_reply
   if (exp_rep > 0) then
      select
         reply_cnam?cnam_rp;
         to managed_reply
      end
   else
      wait [0,0];
      to finish
   end 

from managed_reply
   wait [0,0];
   if (exp_rep > 0) then
      exp_rep := exp_rep - 1;
      to wait_after_rqst
   else
      to finish
   end
